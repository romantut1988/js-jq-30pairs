<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JavaScript</title>
</head>

<body>
  <!-- Методы объектов String и RegExp для работы с регулярными выражениями. -->
  <!-- Вспомним: Работу с регулярными шаблонами обеспечивают как объекты типа RegExp, так и объекты типа String.
  С одним из методов объекта RegExp «test» мы уже познакомились. Напомним — этот метод позволяет проверить, подходит
  ли строка под данный шаблон, и возвращает результат этой проверки.-->

  <!-- Еще один метод объекта RegExp «object/null exec(str)» имеет расширенные возможности по сравнению с методом «test».
  Параметром метода также является строка, обрабатываемая регулярным выражением. Кроме проверки строки на соответствие
  шаблону, метод «exec» обеспечивает поиск тех фрагментов исходной строки, которые совпали с шаблоном. В качестве
  результата своей работы метод возвращает объект с описанием найденного фрагмента либо значение «», если совпадений с
  шаблоном найдено не было. -->
  <!-- Пример «exec»: 
  Задание: ввести console: 
    str = "20% of population owning 80% income"
    template = /\d+/
    template.exec(str) 
  Ввыполняем команду: «template. exec(str)». Сделаем вывод — метод «exec» останавливается после обнаружения первого 
  совпадения с шаблоном 
    template = /\d+/g  
    template.exec(str)    
    template.exec(str)    
  В результате, после первого запуска получится тот же ответ, что и в прошлый раз. Однако повторный вызов метода «exec»
  приведет к новому результату, содержащему следующее найденное число — 80. Поле «index» содержит значение «25»,
  отвечающее за позицию этого числа в исходной строке. Третий вызов метода закончится возвратом «null», что означает 
  невозможность найти следующее совпадение с шаблоном.При наличии флага «g» метод «exec» можно вызывать несколько раз, 
  получая новые совпадения с шаблоном-->


  <!-- Рассмотрим метод «match», кже проверяет строку на соответствие шаблону и, в зависимости от результатов проверки, 
  возвращает объект с найденными фрагментами, либо «null», если совпадений с шаблоном не найдены. В отличие от метода
  «exec» результаты работы метода «match» будут разными для шаблонов с флагом «g» и без него. При записи этого метода
  программная инструкция как бы «переворачивается» — метод «match» вызывается у строковой переменной (str), а в качестве
  аргумента ему передается регулярный шаблон (template):
  str = "20% of population owning 80% income"
  template = /\d+/  
  str.match(template) 
  Затем введем шаблон с флагом глобального поиска и повторим вызов метода 
  template = /\d+/g 
  str.match(template) 
  Из анализа результатов можно сделать следующие выводы. Без флага глобального поиска метод «match» работает так же, как
  и рассмотренный выше метод «RegExp. exec». Однако при наличии флага результат получается другой — в итоговом ответе 
  сразу собраны все совпадения с шаблоном: оба числа «20» и «80» попали в итоговый массив.
  !Если нужны сами числа, то удобнее будет получить их за один запрос методом «String.match» не создавая циклы. Если же
  нужны данные о положении этих чисел в строке, то предпочтение можно отдать методу «RegExp.exec», который эту информацию
  предоставляет в явном виде -->

  <!-- Познакомимся еще одним методом объекта «String», работающим с регулярными выражениями, является «replace». 
  Этот метод позволяет выполнить замену найденных совпадений на другие значения.
  Пример: номер телефона может быть введен пользователем с использованием тире «67-00-53». Для  ввода это допустимо, но 
  для хранения в базе данных эти тире следует убрать.
  str="67-00-53"
  str.replace("-","")
  В метод «replace» передается два параметра. Первый — это то, что нужно заменить. Второй — строка для замены.
  str.replace(/-/g,"")
  добавим пробелы
  str = "67 - 00 - 53"
  str.replace(/[- ]/g,"")
-->


  <!-- !!!Третьим методом объекта «String» (после «match» и «replace»), работающим с регулярными выражениями, является 
  метод «split». Этот метод предназначен для разбиения строки по определенному шаблону. В простейшем случае метод 
  «split» можно использовать без регулярных выражений с обычными строками-разделителями.
  Пример: Создадим две строки с разными вариантами ввода фамилии и имени.
  str1 = "Smith John"
  str2 = "Smith,  John"
  template = /\W+/
  str1.split(template) 
  str2.split(template)
-->


  <!-- В завершение знакомства с работой регулярных выражений рассмотрим еще один часто используемый на практике флаг «i», 
означающий регистронезависимый анализ шаблона. Напомним, что регистронезависимость означает проведение сравнений,
одинаковых как для больших букв (символов верхнего регистра), так и для маленьких (нижнего регистра). Обычное сравнение
(без флага «i») является регистрозависимым, то есть большие и маленькие буквы считаются разными символами.
Пример: нам нужно получить от пользователя подтверждение, содержащее в себе слово «yes». На этапе проектирования предположим 
несколько вариантов ввода, которые мы будет считать допустимыми:
str1="Yes, of course"
str2="well, let it be yes" 
str3="I said YES!"
задаем шаблон
template = /yes/i
template.test(str1)
template.test(str2) 
template.test(str3)
тестируем другой ввод текста без слова "yes" к примеру 
template.test("good") 
template.test("OK")
-->
</body>

</html>